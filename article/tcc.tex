\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{fancyvrb}
\usepackage{caption}
\usepackage{subcaption}

\newcommand\slsh{\char`\\}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=cyan,
    filecolor=blue,      
    urlcolor=cyan,
    citecolor=cyan,
}
 
\sloppy

\title{Estudo relativo ao desempenho em função do consumo sobre alta demanda de dados em sistemas web desenvolvidos com \textit{Node.JS} e \textit{React.JS}}

\author{Marcos Renan Krul\inst{1}, Renato Cristiano Ruppel\inst{1}, Prof. Dr. Adriano Ferrsa\inst{1}}


\address{Universidade Estadual de Ponta Grossa (UEPG)
    \email{19022626@uepg.br, 19010426@uepg.br, ferrasa@uepg.br}
}


\begin{document} 

\maketitle


\begin{resumo} 
\end{resumo}


\begin{abstract} 
\end{abstract}


\section{Introdução}

O desenvolvimento de novas aplicações e a migração das já existentes para a plataforma \textit{web} 
vêm crescendo e se tornando uma tendência \cite{SOUZAB}. Existem benefícios que justificam esse comportamento,
como facilidades em instalações e atualizações, alcance global instantâneo e alta portabilidade. Porém,
sob outra perspectiva, apresentam-se questões críticas que devem ser analisadas antes de aderir à plataforma, como
o desempenho em situações com alta demanda de dados.

O uso de \textit{Node.JS} e \textit{React.JS}, duas tecnologias em crescente uso e relevância no
desenvolvimento \textit{web}, justifica-se pelo fato de que estas permitem uma abordagem de alta
performance e apresentam recursos para otimização e escalabilidade. O \textit{Node.JS}, em específico, apresenta
bons resultados em casos que necessitem da persistência de centenas ou milhares de conexões
simultâneas, onde a comunicação é realizada com o envio de pequenos fragmentos do arquivo de destino
\cite[p. 112]{EJSMONT}. Quanto à camada \textit{front-end}, a biblioteca \textit{React.JS} traz como
carro chefe o gerenciamento de estado da aplicação, orientado a dados que podem mudar com o passar do tempo.
Ao incluir estado em uma aplicação utilizando \textit{React.JS}, inclui-se a possibilidade de criar, ler
e modificar dados dinâmicos enviados pelo servidor, que modificam a árvore de componentes e acarretam 
mudanças na interface em que o usuário interage \cite[p. 97]{BANKSEPORCELLO}.

Aplicações como \textit{streaming} de vídeo (ADICIONAR OUTROS EXEMPLOS) devem processar arquivos de 
grande porte, de forma rápida e estável. Contudo, existem limitações inerentes ao uso da 
plataforma \textit{web}, como o processamento de diversas requisições que exijam muitos dados, 
tratamento do alto fluxo de dados pela máquina cliente e os limites impostos pelas tecnologias escolhidas.

Para sobrepujar os problemas supracitados, existem técnicas desenvolvidas para a \textit{web} que buscam
atenuar os problemas de alta demanda e torná-los irrisórios na experiência do usuário, como o processamento
assíncrono (\textit{streams}) e \textit{caching}. Faz-se necessário, portanto, desenvolver um estudo das 
técnicas escolhidas para aumentar o desempenho em alta demanda de dados utilizando os \textit{frameworks} 
escolhidos.


% À medida que a computação como um todo evoluiu, desde a comunicação
% utilizando apenas bits, para a comunicação com dados mais complexos e robustos,
% a criação e implementação de novas técnicas que adaptem a manipulação de novas
% formas de dados mantendo performance, simplicidade e robustez, torna-se um
% desafio.

% Todo projeto de software precisa de estimativas e planejamento, mas quando
% tem-se um sistema desenvolvido para a web, principalmente onde exista grandes
% volumes de dados, o termo escalabilidade deve se tornar muito mais presente na
% concepção do projeto.

% O termo escalabilidade pode ser definido como a maneira de ajustar a
% capacidade de um sistema para atender demandas, de forma que o custo desta
% operação não seja tão elevado. \cite[p. 3]{EJSMONT}. A incorporação de
% escalabilidade em um sistema pode compreender a capacidade de lidar com um
% crescimento de usuários, solicitações e transações, para este projeto, seu uso será
% voltado para a requisição e transferência de grandes volumes de dados.


\section{Revisão de bibliografia e trabalhos relacionados}

\subsection{Padrões de projeto no Node.JS}

Padrões de projeto são soluções previamente definidas para problemas específicos que, geralmente,
são comuns ao desenvolvimento do \textit{software} de diversas aplicações. Não são, necessariamente, 
bibliotecas ou módulos prontos, apenas carregam o conceito de uma solução já comprovada e testada para um 
determinado caso, sendo, dessa forma, necessária a implementação destes na 
linguagem escolhida. \cite[p. 13]{DIOGORESENDE}

Um único \textit{software} pode ser implementado com diferentes padrões de projeto e, até mesmo, com a união
de dois ou mais. Os padrões apresentam diversos benefícios, como aumento da produtividade, manutenção e comunicação
entre a equipe de desenvolvimento. Contudo, a definição das soluções arquiteturais adotadas deve ser 
cuidadosa, visto que escolhas incorretas podem acarretar em novos empecilhos. Dentre outras, 
alguns \textit{designs} adicionam camadas extras de processamento para obter maior flexibilidade, podendo, dessa forma, 
afetar as métricas de desempenho do sistema final. \cite[p. 13 - p. 14]{DIOGORESENDE}

Dentre a maioria dos padrões de projeto conhecidos, existem aqueles que são amplamente utilizados no 
\textit{Node.JS}, devido à sua estrutura e ao seu modelo de interface. Dentre eles, evidenciam-se
os padrões de fluxo de eventos e os orientados a eventos, já presentes e fundamentados na interface principal 
da plataforma. É possível, por exemplo, substituir o modo de leitura de um arquivo de 
uma simples função somada à uma \textit{callback}, que irá consumir mais recursos de máquina, para um fluxo de 
leitura onde é possível verificar os eventos de dados e de conclusão, ou até mesmo encaminhar o fluxo para 
outra camada de processamento. Da mesma forma que ocorre com os arquivos, o controle dos eventos 
de conexão, recebimento de dados e encerramento está presente em módulos principais como, por exemplo, 
o \textit{http}. Em suma, eventos são recursos fundamentais do \textit{Node.JS}. \cite[p. 15]{DIOGORESENDE}


\subsection{Arquitetura orientada a eventos}

Este padrão de projeto baseia-se na ideia de produção e consumo de eventos, sendo que o consumo pode ser feito por um
ou mais ouvintes ao mesmo tempo. A implementação da parte consumidora deve garantir que haja uma reação ao 
acontecimento de eventos, ao invés de simplesmente tentar detectar mudanças nos dados recebidos. \cite[p. 27]{DIOGORESENDE}

Ao adotar este tipo de arquitetura em um projeto, a aplicação passa a ter o fluxo de informação controlado pelo disparo
de eventos, o que, dependendo do caso, pode ser a melhor escolha de padrão, porém, ainda é preciso se atentar a alguns
detalhes e desvantagens ao utilizar esta abordagem. Como o fluxo de dados da aplicação é dependente do acontecimento
de certos eventos, é preciso ter cuidado extra no código para não permitir brechas que podem levar a um \textit{deadlock},
em outras palavras, uma trava que impossibilita o prosseguimento do fluxo imaginado para a aplicação. Um 
\textit{deadlock} pode ocorrer quando, por motivos de implementação incorreta, um evento alvo esperado pelo
consumidor não é acionado, fazendo com que este fique preso em um ponto exato, não podendo avançar nem regredir.
A segunda questão a ser observada, que também vale para outros tipos de padrões, é o tratamento de erros consistente
e robusto. Ao passo que o ponto anterior pode não ser fatal para a aplicação como um todo, ignorar erros, principalmente
os lançados por módulos principais, acarretará em paradas fatais da aplicação. \cite[p. 28]{DIOGORESENDE}


\subsection{\textit{Stream}}


\subsection{\textit{Buffer}}

Os \textit{buffers}, no \textit{Node.JS}, são objetos especiais utilizados para armazenamento e processamento 
de dados binários, o que não seria possível operando com tipos primitivos do \textit{JavaScript} como \textit{strings},
por exemplo, visto que estas são codificadas em \textit{Unicode}. \cite[p. 29]{DIOGORESENDE}

Além da possibilidade de manipulação de dados binários e da facilidade em leituras e escritas de números de diferentes 
tamanhos, os \textit{buffers} são uma importante estrutura na plataforma do \textit{Node.JS} em relação à arquitetura
orientada a eventos, dada a compatibilidade binária existente entre os principais módulos da plataforma que 
utilizam estes nos eventos de dados. Dessa forma, é possível que arquivos sejam transmitidos ao cliente de maneira 
simplificada, ao modo que esta operação se resume ao encadeamento de fluxos com a troca de 
\textit{buffers} entre cliente e servidor. \cite[p. 29]{DIOGORESENDE}


\subsection{\textit{Cache}}

% Caching is one of the most important techniques when it comes to scaling the
% front end of your web application. Instead of trying to add more servers or make
% them respond faster to clients’ requests, use caching to avoid having to serve
% these requests in the first place. In fact, caching is so critical to the scalability of
% web applications that Chapter 6 is dedicated to it. To avoid repeating parts of that
% deeper dive, let’s just highlight a few components relevant to the front-end layer
% of your application here. (p 133 livro);


\section{Metodologia}

\subsection{Revisão sistemática da literatura}

% 1. Revisão bibliográfica de documentação e artigos referentes à
% linguagem e frameworks escolhidos para o tratamento de alta
% demanda de dados.
% 2. Análise de casos e implementações feitas pela comunidade
% desenvolvedora de software.
% 3. Comparação de diferentes implementações feitas em sistemas web
% para a manipulação e transferência de alto volume de dados.
% 4. Desenvolvimento de aplicações cliente e servidor para transferência de
% alto volume de dados.

\section{Resultados e discussão}


\section{Conclusão}


\section{Referências}
\bibliographystyle{sbc}
\bibliography{referencias}

\end{document}